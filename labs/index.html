<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8"/>
        <title>mass Framework</title>


        <script type="text/javascript" src="../src/mass.js" charset="UTF-8"></script>
        <script type="text/javascript" src="ko.js" charset="UTF-8"></script>

        <script>

        </script>

    </head>
    <body>
        <h4>People</h4>
        <ul data-bind="foreach: people">
            <li>
                Name at position <span data-bind="text: $index"> </span>:
                <span data-bind="text: name"> </span>
                <a href="#" data-bind="click: $parent.removePerson">Remove</a>
            </li>
        </ul>
        <button data-bind="click: addPerson">Add</button>

        <script type="text/javascript">
            $.require("ready,more/avalon", function(){

                function AppViewModel() {
                    var self = this;

                    self.people = ko.observableArray([
                        { name: 'Bert' },
                        { name: 'Charles' },
                        { name: 'Denise' }
                    ]);

                    self.addPerson = function() {
                        self.people.push({ name: "New at " + new Date() });
                    };

                    self.removePerson = function() {
                        self.people.remove(this);
                    }
                }
                var model = new AppViewModel()
                //      ko.applyBindings(model);
            });
            var changeArray = function(a){
                var ret = []
                for(var i=0, n = a.length; i<n;i++){
                    ret[ret.length] = {
                        index:i,
                        value:a[i]
                    }
                }
                return ret;
            }
            var actionScript = function( a, b ){
                var prev = changeArray(a);
                if(b.length){
                    prev.forEach(function(obj){
                        obj.action = "add"
                    })
                }else{
                    prev.forEach(function(obj, i){
                        obj.action = "add"
                    })
                }
                return prev;
            }

           
            // 一个简单的Levenshtein distance算法
            //编辑距离就是用来计算从原串（s）转换到目标串(t)所需要的最少的插入，删除和替换的数目，
            //在NLP中应用比较广泛，如一些评测方法中就用到了（wer,mWer等），同时也常用来计算你对原文本所作的改动数。
            function calculateEditDistanceMatrix(oldArray, newArray, maxAllowedDistance) {
                var distances = [];
                for (var i = 0; i <= newArray.length; i++)
                    distances[i] = [];

                // Top row - transform old array into empty array via deletions
                for (var i = 0, j = Math.min(oldArray.length, maxAllowedDistance); i <= j; i++)
                    distances[0][i] = i;

                // Left row - transform empty array into new array via additions
                for (var i = 1, j = Math.min(newArray.length, maxAllowedDistance); i <= j; i++) {
                    distances[i][0] = i;
                }

                // Fill out the body of the array
                var oldIndex, oldIndexMax = oldArray.length, newIndex, newIndexMax = newArray.length;
                for (oldIndex = 1; oldIndex <= oldIndexMax; oldIndex++) {
                    var newIndexMinForRow = Math.max(1, oldIndex - maxAllowedDistance);
                    var newIndexMaxForRow = Math.min(newIndexMax, oldIndex + maxAllowedDistance);
                    for (newIndex = newIndexMinForRow; newIndex <= newIndexMaxForRow; newIndex++) {
                        if (oldArray[oldIndex - 1] === newArray[newIndex - 1])
                            distances[newIndex][oldIndex] = distances[newIndex - 1][oldIndex - 1];
                        else {
                            var northDistance = distances[newIndex - 1][oldIndex] === undefined ? Number.MAX_VALUE : distances[newIndex - 1][oldIndex] + 1;
                            var westDistance = distances[newIndex][oldIndex - 1] === undefined ? Number.MAX_VALUE : distances[newIndex][oldIndex - 1] + 1;
                            distances[newIndex][oldIndex] = Math.min(northDistance, westDistance);
                        }
                    }
                }
                console.log(distances.join("\n"))
                return distances;
            }

            function findEditScriptFromEditDistanceMatrix(editDistanceMatrix, oldArray, newArray) {
                var oldIndex = oldArray.length;
                var newIndex = newArray.length;
                var editScript = [];
                var maxDistance = editDistanceMatrix[newIndex][oldIndex];
                if (maxDistance === undefined)
                    return null; // maxAllowedDistance must be too small
                while ((oldIndex > 0) || (newIndex > 0)) {
                    var me = editDistanceMatrix[newIndex][oldIndex];
                    var distanceViaAdd = (newIndex > 0) ? editDistanceMatrix[newIndex - 1][oldIndex] : maxDistance + 1;
                    var distanceViaDelete = (oldIndex > 0) ? editDistanceMatrix[newIndex][oldIndex - 1] : maxDistance + 1;
                    var distanceViaRetain = (newIndex > 0) && (oldIndex > 0) ? editDistanceMatrix[newIndex - 1][oldIndex - 1] : maxDistance + 1;
                    if ((distanceViaAdd === undefined) || (distanceViaAdd < me - 1)) distanceViaAdd = maxDistance + 1;
                    if ((distanceViaDelete === undefined) || (distanceViaDelete < me - 1)) distanceViaDelete = maxDistance + 1;
                    if (distanceViaRetain < me - 1) distanceViaRetain = maxDistance + 1;

                    if ((distanceViaAdd <= distanceViaDelete) && (distanceViaAdd < distanceViaRetain)) {
                        editScript.push({
                            status: "added",
                            value: newArray[newIndex - 1]
                        });
                        newIndex--;
                    } else if ((distanceViaDelete < distanceViaAdd) && (distanceViaDelete < distanceViaRetain)) {
                        editScript.push({
                            status: "deleted",
                            value: oldArray[oldIndex - 1]
                        });
                        oldIndex--;
                    } else {
                        editScript.push({
                            status: "retained",
                            value: oldArray[oldIndex - 1]
                        });
                        newIndex--;
                        oldIndex--;
                    }
                }
                return editScript.reverse();
            }
            //用于比较一个对象数组
            var compareArrays = function (oldArray, newArray, maxEditsToConsider) {
                if (maxEditsToConsider === undefined) {
                    return compareArrays(oldArray, newArray, 1)             // First consider likely case where there is at most one edit (very fast)
                        || compareArrays(oldArray, newArray, 10)                // If that fails, account for a fair number of changes while still being fast
                        || compareArrays(oldArray, newArray, Number.MAX_VALUE); // Ultimately give the right answer, even though it may take a long time
                } else {
                    oldArray = oldArray || [];
                    newArray = newArray || [];
                    var editDistanceMatrix = calculateEditDistanceMatrix(oldArray, newArray, maxEditsToConsider);
                    console.log(editDistanceMatrix.join("\n"))
                    //   cnosole.log(editDistanceMatrix)
                    return findEditScriptFromEditDistanceMatrix(editDistanceMatrix, oldArray, newArray);
                }
            };
            console.log("==========")
            //  var a = compareArrays("GUMBO","AAMBOLD");
            //http://www.cnblogs.com/pandora/archive/2009/12/20/levenshtein_distance.html
            //https://gist.github.com/982927
            var getEditDistance = function(from, to){
                //   if(a.length == 0) return b.length;
                //   if(b.length == 0) return a.length;
                var matrix = [], fn = from.length, tn = to.length;
                // 初始化一个矩阵,行数为b,列数为a
                var i,j
                for(i = 0; i <= tn; i++){
                    matrix[i] = [i];//设置第一列的值
                }
                for(j = 0; j <= fn; j++){
                    matrix[0][j] = j;//设置第一行的值
                }
                // 填空矩阵
                for(i = 1; i <= tn; i++){
                    for(j = 1; j <= fn; j++){
                        if(to.charAt(i-1) == from.charAt(j-1)){
                            matrix[i][j] = matrix[i-1][j-1];//没有改变
                        } else {
                            matrix[i][j] = Math.min(matrix[i-1][j-1] + 1, //代替 substitution
                            matrix[i][j-1] + 1, // 插入insertion
                            matrix[i-1][j] + 1); //删除 deletion
                        }
                    }
                }
                console.log(matrix.join("\n"))
                return matrix
            };
            var getEditScripts = function(from, to, matrix){
                var x = from.length;
                var y = to.length;
               
                var cost = matrix[y][x];
                console.log(cost)
                var i =  Math.max(x,y);
                var scripts = [], action
                while(scripts.length != i ){
                    var cur = matrix[y][x];//如果matrix[y]为undefined
                    var top = matrix[y-1][x]
                    var left = matrix[y][x-1]
                    console.log("top["+(y-1)+"]["+x+"] : " + top+"    left["+y+"]["+(x-1)+"] : "+left+"   cur["+y+"]["+x+"]: "+cur)
                    if(top == left){
                        scripts[scripts.length] = {
                            action: top == cur ?  "update" : "retain"
                        }
                        x--;
                        y--
                        if(top == cur){
                            cost--;
                        }
                    }else{
                      
                        if( top + 1 == cur ){
                            action = "add";
                            y--;
                            cost--;
                        }
                        if( left + 1 == cur){
                            action = "delete";
                            x--;
                            cost--;
                        }
                        //console.log(matrix[y][x])
                        scripts[scripts.length] = {
                            action:  action
                        }
                    }
                }
                console.log(scripts.reverse())

            }

            //  var m = getEditDistance( "AA","AA");
            //  getEditScripts("AA","AA",m)
            //   console.log("===================")
            //   getEditDistance( "ABCD","ADCD")
            // console.log("===================")
            //   getEditDistance( "ABCDE","ABCD");
            console.log("===================")
            var old = "ABCDE", neo = "OBCDEK"
            var m = getEditDistance( old, neo);
            getEditScripts( old, neo,m)
            //  console.log("===================")
            // getEditDistance( "AAA","CCC");
            //    var matrix = [[],[]];
            //倒序
            //如果它等于上边的与左边的说明发现改变

        </script>

    </body>
</html>

