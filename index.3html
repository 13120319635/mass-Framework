<!DOCTYPE HTML>
<html>
    <head>
        <title>SAW规范的模块加载例子 by 司徒正美</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <style>
            html,body{
                height:100%;
            }
        </style>
        <script src="mass.js">

        </script>
        <script>
            //加载当前目录下的more目录的aaa.js
            $.require("./more/aaa", function(a){
                $.log(a)
            })

        </script>
    </head>
    <body>
        <h1>SAW规范的模块加载例子 by 司徒正美</h1>
    </body>
</html>
<p>随着avalon v2项目的启动，我又开始学习业内的各个MVVM框架。在一次偶然机会，幸运接触到计算机之子<a href="http://winter-cn.cnblogs.com/">winter-cn</a>的MVVM源码，需要认真学习一下。</p>
<p>不过，这放出来是比较早期的源码，现在可能改进很多，膜拜地址：<a href="http://shaofei.name/mvvm/">http://shaofei.name/mvvm/</a></p>
<p>计算机之子的MVVM现在只支持非常高级的浏览器，还在使用IE678这样破浏览器，就免进吧，人家的高瞻远瞩岂非尔等屌丝所能想象的！</p>
<p>他的框架由三个文件组成，分别是EventSource.js，ViewModel.js，HTMLTemplate.js。</p>
<p>EventSource其实就可以看作为W3C的EventTarget类，是提供观察者模式的机制，没什么好说的。</p>
<pre class="brush:js;gutter:false;toolbar:false;">
function EventSource() {
    var eventHandlers = {};
    this.addEventListener = function (type, handler) {//绑定事件
        if (!eventHandlers[type]) {
            eventHandlers[type] = [];
        }
        eventHandlers[type].push(handler);
    };
    this.removeEventListener = function (type, handler) {//卸载事件
        if (!eventHandlers[type]) {
            return;
        }
        eventHandlers[type] = eventHandlers[type].filter(function (f) {
            return f != handler;
        })
    };
    this.dispatchEvent = function (e) {//派发事件
        if (eventHandlers.hasOwnProperty(e.type)) {
            eventHandlers[e.type].forEach(function (f) {
                f.call(this, e);
            })
        }
        if (this["on" + e.type]) {
            this["on" + e.type](e);
        }
    }
}
</pre>
<p>ViewModel.js里面提供了两个EventSource的子类，分别叫做ViewModel与ArrayViewModel,功效类于backbone的Model与Collection，或knouckout的ko.observable与ko.observableArray。不过backbone这样的垃圾怎么能与MVVM这样的高级货相提并论呢，死到一边凉快吧！</p>
<pre class="brush:js;gutter:false;toolbar:false;">

function ViewModel(data,parent) {
    if(data instanceof Array)//由于只针对当前页面，instanceof就足够了，不过既然不支持IE，可以用上Array.isArray
        return new ArrayViewModel(data,parent);
    var children = {};
    var me = this;
    for(var p in data) {
        if(data.hasOwnProperty(p)) {
            void function(p){//一个闭包
                //通过属性描述符将用户的对象的属性变成ViewModel实例的具有访问器特性的属性
                Object.defineProperty(this,p,{
                    get:function(){//当用户使用“aaa.bbb”来访问此属性时调用此函数
                        if(typeof data[p] == "object")
                            return children[p];
                        else return data[p];
                    },
                    set:function(v){//当用户使用“aaa.bbb = v”进行赋值时调用此函数
                        data[p] = v ;
                        if(typeof data[p] == "object") {//这里没有必要吧，★★★★处已经写过了
                            children[p] = new ViewModel(data[p]);
                            children[p].addEventListener("propertyChange",function(e){
                                me.dispatchEvent({
                                    type:"propertyChange",
                                    propertyName:p,
                                    path:p+"."+e.path
                                });
                            })
                        }
                        //同时向它的订阅者派发此事件，事件对象只是一个普通对象，分别描述事件类型，属性名，与属性路径（即此属性是属于某个属底下）
                        this.dispatchEvent({
                            type:"propertyChange",
                            propertyName:p,
                            path:p
                        });
                    }
                });
                if(typeof data[p] == "object") {//★★★★如果属性又是一个对象，则递归一下。不过应该判定值为null的情况！
                    children[p] = new ViewModel(data[p]);
                    //为它的属性绑定propertyChange事件
                    children[p].addEventListener("propertyChange",function(e){
                        me.dispatchEvent({
                            type:"propertyChange",
                            propertyName:p,
                            path:p+"."+e.path
                        });
                    })
                }
            }.call(this,p);
        }
    }
    EventSource.call(this);
}
</pre>
<p>ArrayViewModel已ViewModel大量小异，就是换一种循环方式：</p>
<pre class="brush:js;gutter:false;toolbar:false;">
function ArrayViewModel(data,parent) {
    var me = new Array(data.length);
    var children = {};
    for(var i = 0; i < data.length; i++) {
        void function(p){
            Object.defineProperty(this,p,{
                get:function(){
                    if(typeof data[p] == "object")
                        return children[p];
                    else return data[p];
                },
                set:function(v){
                    data[p] = v ;
                    if(typeof data[p] == "object") {//我还是觉得这里没有必要
                        children[p] = new ViewModel(data[p]);
                        children[p].addEventListener("propertyChange",function(e){
                            me.dispatchEvent({
                                type:"propertyChange",
                                propertyName:p,
                                path:p+"."+e.path
                            });
                        })
                    }
                    this.dispatchEvent({
                        type:"propertyChange",
                        propertyName:p,
                        path:p
                    });
                }
            });
            if(typeof data[p] == "object") {
                children[p] = new ViewModel(data[p]);
                children[p].addEventListener("propertyChange",function(e){
                    me.dispatchEvent({
                        type:"propertyChange",
                        propertyName:p,
                        path:p+"."+e.path
                    });
                })
            }
        }.call(me,i);
    }
    EventSource.call(me);
    return me;
}
</pre>
<p>我的建议是把它们压缩成这样：</p>

<pre class="brush:js;gutter:false;toolbar:false;">

function defineProperty(me, children, data, p){
    Object.defineProperty(me, p,{
        get:function(){
            if(typeof data[p] == "object")
                return children[p];
            else return data[p];
        },
        set:function(v){
            data[p] = v ;
            me.dispatchEvent({
                type:"propertyChange",
                propertyName:p,
                path:p
            });
        }
    });
    if(typeof data[p] == "object") {//犹豫要不要识别null
        children[p] = new ViewModel(data[p]);
        children[p].addEventListener("propertyChange",function(e){
            me.dispatchEvent({
                type:"propertyChange",
                propertyName:p,
                path:p+"."+e.path
            });
        })
    }
}

//这个new不new都没所谓!
function ArrayViewModel(data,parent) {
    var me = new Array(data.length);
    for(var i = 0; i < data.length; i++) {
        defineProperty(me, {}, data, i);
    }
    EventSource.call(me);
    return me;
}

function ViewModel(data,parent) {
    if( Array.isArray(data))
        return new ArrayViewModel(data,parent);
    for(var p in data) {
        if(data.hasOwnProperty(p)) {
            defineProperty(this, {}, data, p);
        }
    }
    EventSource.call(this);
}
</pre>